\documentclass[11pt]{amsart}
\usepackage{master}
% \usepackage[margin=1in]{geometry}

\begin{document}
\title{Computational trinitarianism}
\author{Jackson Van Dyke}
\date{Last edited: \today}
\maketitle

This is a highly condensed version of \cite{BS_comp_trin}.

\section{Category theory}

\begin{defn}
A \emph{category} $\cat{C}$ consists of:
\begin{itemize}
\item a set (or class) of \emph{objects} (if $X$ is an object we write $X\in \cat{C}$) and
\item for every pair of objects $X,Y\in \cat{C}$, a set of \emph{morphisms from $X$ to
$Y$}, written $\Hom\left(X , Y\right)$.
For $f\in \Hom\left(X , Y\right)$ we write $f : X\to Y$.
\end{itemize}
These have to satisfy the following:
\begin{itemize}
\item for every objects there is an identity morphism $1_X \in \Hom\left(X , X\right)$;
\item for $f : X\to Y$ and $g : Y\to Z$, there is a
composite morphism $gf : X\to Z$;
\item composition is associative: $\left(hg\right)f = h\left(gf\right)$.
\end{itemize}
\end{defn}

\begin{exm}
There is a category $\Set$. The objects are sets, and the morphisms are set-theoretic
functions.
\end{exm}

\begin{exm}
There is a category $\Vect_k$. The objects are vector spaces over a field $k$, and
morphisms are linear maps.
\end{exm}

\begin{exm}
There is a category $\Hilb$. The objects are (finite dimensional) Hilbert spaces and the
morphisms are linear maps (automatically bounded in this case).
\end{exm}

\begin{defn}
Let $\cat{C}$ and $\cat{D}$ be categories.
A functor $F : \cat{C} \to \cat{D}$ is a function on the sets of objects such that
for any morphism $f : X\to Y$ there is a 
morphism $F\left(f\right) : F\left(X\right) \to F\left(Y\right)$ such that
\begin{itemize}
\item for any $X\in \cat{C}$, $F\left(1_X\right) = 1_{F\left(X\right)}$ and
\item for any two morphisms $f : X\to Y$ and $g : Y\to Z$, 
\begin{equation}
F\left(gf\right) = F\left(g\right) F\left(f\right) \ .
\end{equation}
\end{itemize}
\end{defn}

The point is that categories consist of things, and ways to get between things. Physics,
logic, and computer science (type theory) also all have things, and processes between them. 
If we ask for different notions of things and processes in these settings, they will
correspond to asking for different structures on the corresponding category. 

For example, it is possible to formalize a notion of a categories having a ``product
structure'' (in the case of $\Vect$ or $\Hilb$ this is literally the tensor product of
vector spaces).

\section{Physics}

Write the dimension of space as $n-1$.
Then we can imagine that time contributes a single additional dimension, so spacetime is
dimension $n$. But we don't want to allow any $n$-dimensional manifold to be spacetime.
Instead, we restrict our attention to what is called a \emph{cobordism}. 

\begin{defn}
Let $M$ and $N$ be $n-1$-dimensional manifolds.
A \emph{cobordism between $M$ and $N$} is a manifold with boundary $W$ of dimension $n$ 
such that 
\begin{equation}
\p W = M\dun N
\ .
\end{equation}
\end{defn}

\begin{exm}
Let $n = 1$. This means space is dimension $0$, i.e. points, and a cobordism is a line
between points (or a circle, which is regarded as a cobordism from the empty set to
itself).
\end{exm}

\begin{exm}
Let $n = 2$. This means space is dimension $1$, i.e. lines or circles, and 
a cobordism is a surface with those circles or lines as its boundary.
\end{exm}

\begin{thm}
There is a category $\Cob_n$. The objects are $n-1$-dimensional manifolds and the
morphisms are cobordisms between them.
\end{thm}

\begin{wrn}
We are leaving our many details about cobordism categories.
There are many types of them given by what we ask for from the objects, e.g. a smooth
structure, a metric, the
conformal class of the metric, etc.
\end{wrn}

\begin{defn}
A quantum field theory is a functor
\begin{equation}
Z : \Cob_n \to \Hilb \ .
\end{equation}
That is, it sends space to a Hilbert space of states, and it sends spacetime to a linear
map between Hilbert spaces (of bounded norm).
\end{defn}

\begin{exm}
Quantum mechanics is a $1$-dimensional QFT in this sense.
\end{exm}

\begin{rmk}
This is the first layer of a very fat onion of $\left(\infty , n\right)$-categories and
the cobordism hypothesis.
\end{rmk}

\section{Logic}

\emph{Propositional calculus} allows one to
reason with abstract propositions.
Given a starting collection of propositions, we can build propositions out of them
using connectives such as $\land$, $\lor$,
$\implies$, $\neg$, $\top$, and $\bot$.
Then there are some formal rules (e.g. Modus Ponens) which tell us how we are allowed to manipulate
propositions to prove other propositions.

Given a flavor of logic (i.e. choice of inference rules, etc.), we can build a category. 
In particular, we take the propositions as objects, and take (equivalence classes
of\footnote{The equivalence relation is generated by some specified inference rules.})
proofs as the morphisms.

\begin{exm}
Intuitionistic propositional logic (i.e. propositional logic with no law of excluded
middle) corresponds to a cartesian closed category.
\end{exm}

As we add or remove more rules, and indeed pass to more complicated settings 
such as predicate logic, we get different flavors of categories.

\section{Type theory}

In certain forms, type theory offers an alternative to set theory as a foundation for
mathematics. Very roughly speaking, this goes as follows.
We start with an arbitrary set of \emph{types}. We should think of a type as a collection
of things sharing a similar property.
When $a$ is of type $X$, we write $a : X$ and say $a$ is a term of type $X$.
We will insist on having a trivial type $I$.
We will also insist on having a term $1:I$.

\begin{exm}
There is a natural number type, an 
integer type, a group type, etc.
The natural number $2$ is a term of type $\NN$, i.e. $2:\NN$.
\end{exm}

Then we have rules for forming new types from given types. For example, given
two types $X$ and $Y$, we can form the function type $X\to Y$ and the product type $X\tp Y$.

Given a particular type theory, there is a category associated to it. The types are the 
objects, and the morphisms between two types $X$ and $Y$ 
are given by (equivalence classes of\footnote{Two terms are
considered equivalent if they differ by some given \emph{rewrite rules}.}) terms of type
$X\to Y$.
We should think of the morphisms as \emph{programs} which take in data of type $X$ and
output data of type $Y$.

\section{Rosetta stone}

In summary, we have the following Rosetta Stone\cite{BS_comp_trin}:
\begin{center}
\begin{tabular}{|c||c|c|c|c|}
\hline
Category th'y & Physics & Topology & Logic & Computation\\
\hline
\hline
object & Hilbert space & manifold & proposition & data type \\
\hline
morphism & operator & cobordism & proof & program \\
\hline
$\tp$ & $\tp$ & disjoint union & conjunction& product \\
\hline
terminal obj. & $\left\{0\right\}$ & $\emp$ & True & triv. type $I$ \\
\hline
initial obj. & $\left\{0\right\}$ & $\emp$ & False & empty type\\
\hline
\end{tabular}
\end{center}

% Fakesection
\bibliographystyle{alpha}
\bibliography{math}

\end{document}
